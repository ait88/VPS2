#!/bin/bash
# wordpress-mgmt/lib/nginx.sh - Nginx configuration with WAF support
# Version: 3.0.3

configure_nginx() {
    info "Configuring Nginx web server..."
    
    if state_exists "NGINX_CONFIGURED"; then
        info "✓ Nginx already configured"
        return 0
    fi
    
    # Configuration steps
    show_progress 1 6 "Setting up PHP-FPM pool"
    setup_php_fpm_pool
    
    show_progress 2 6 "Configuring WAF/Proxy settings"
    configure_waf_settings
    
    show_progress 3 6 "Creating virtual host"
    ensure_temporary_ssl_certificates
    create_virtual_host
    
    show_progress 4 6 "Setting up security headers"
    configure_security_headers
    
    show_progress 5 6 "Enabling site configuration"
    enable_site_config
    
    show_progress 6 6 "Testing configuration"
    test_nginx_config
    
    save_state "NGINX_CONFIGURED" "true"
    success "✓ Nginx configured successfully"
}

setup_php_fpm_pool() {
    local php_version=$(load_state "PHP_VERSION" "8.2")
    local php_user=$(load_state "PHP_USER" "php-fpm")
    local wp_user=$(load_state "WP_USER")
    local pool_name="${wp_user}_pool"
    
    info "Creating dedicated PHP-FPM pool..."
    
    # Create pool configuration
    sudo tee "/etc/php/$php_version/fpm/pool.d/$pool_name.conf" >/dev/null <<EOF
; WordPress PHP-FPM Pool Configuration
; Generated by setup-wordpress.sh

[$pool_name]

; Unix user/group of processes
user = $php_user
group = wordpress

; Socket configuration
listen = /run/php/php${php_version}-fpm-$pool_name.sock
listen.owner = www-data
listen.group = www-data
listen.mode = 0660

; Process manager configuration
pm = dynamic
pm.max_children = $(load_state "PHP_WORKERS" "10")
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
pm.max_requests = 500

; Process configuration
request_terminate_timeout = 300s
request_slowlog_timeout = 5s
slowlog = /var/log/php/${php_version}-fpm-$pool_name-slow.log

; Environment variables
env[HOSTNAME] = \$HOSTNAME
env[PATH] = /usr/local/bin:/usr/bin:/bin
env[TMP] = /tmp
env[TMPDIR] = /tmp
env[TEMP] = /tmp

; PHP configuration overrides
php_admin_value[error_log] = /var/log/php/${php_version}-fpm-$pool_name-error.log
php_admin_flag[log_errors] = on
php_admin_value[memory_limit] = $(load_state "PHP_MEMORY_LIMIT" "256M")
php_admin_value[upload_max_filesize] = 64M
php_admin_value[post_max_size] = 64M
php_admin_value[max_execution_time] = 300
php_admin_value[max_input_time] = 300
php_admin_value[max_input_vars] = 3000

; Security restrictions
php_admin_value[disable_functions] = exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source
php_admin_flag[allow_url_fopen] = off
php_admin_flag[allow_url_include] = off
php_admin_value[open_basedir] = $(load_state "WP_ROOT"):/tmp:/usr/share/php

; Session configuration
php_admin_value[session.save_path] = /var/lib/php/sessions/$pool_name
EOF
    
    # Create session directory
    sudo mkdir -p "/var/lib/php/sessions/$pool_name"
    sudo chown "$php_user:wordpress" "/var/lib/php/sessions/$pool_name"
    sudo chmod 770 "/var/lib/php/sessions/$pool_name"
    
    # Create log directory
    sudo mkdir -p /var/log/php
    sudo chown "$php_user:wordpress" /var/log/php
    
    # Restart PHP-FPM
    restart_service "php${php_version}-fpm"
    
    save_state "PHP_FPM_SOCKET" "/run/php/php${php_version}-fpm-$pool_name.sock"
    debug "PHP-FPM pool configured"
}

configure_waf_settings() {
    local waf_type=$(load_state "WAF_TYPE" "none")
    
    info "Configuring WAF/Proxy settings..."
    
    case "$waf_type" in
        "cloudflare"|"cloudflare_ent")
            setup_cloudflare_real_ip
            ;;
        "sucuri")
            setup_sucuri_real_ip
            ;;
        "bunkerweb")
            setup_bunkerweb_real_ip
            ;;
        "custom")
            setup_custom_real_ip
            ;;
        "none")
            info "No WAF configured - direct access"
            ;;
    esac
}

setup_cloudflare_real_ip() {
    info "Fetching Cloudflare IP ranges..."
    
    local cf_conf="/etc/nginx/conf.d/cloudflare-real-ip.conf"
    
    # Download current Cloudflare IPs
    {
        echo "# Cloudflare IP ranges - Updated $(date)"
        echo "# Auto-generated by setup-wordpress.sh"
        echo
        
        # IPv4
        curl -s https://www.cloudflare.com/ips-v4 | while read ip; do
            echo "set_real_ip_from $ip;"
        done
        
        echo
        
        # IPv6
        curl -s https://www.cloudflare.com/ips-v6 | while read ip; do
            echo "set_real_ip_from $ip;"
        done
        
        echo
        echo "real_ip_header CF-Connecting-IP;"
        echo "real_ip_recursive on;"
    } | sudo tee "$cf_conf" >/dev/null
    
    # Create update script
    sudo tee /etc/cron.weekly/update-cloudflare-ips >/dev/null <<'EOF'
#!/bin/bash
# Update Cloudflare IP ranges weekly

CF_CONF="/etc/nginx/conf.d/cloudflare-real-ip.conf"
TEMP_FILE="/tmp/cloudflare-ips.tmp"

{
    echo "# Cloudflare IP ranges - Updated $(date)"
    echo "# Auto-generated by setup-wordpress.sh"
    echo
    
    curl -s https://www.cloudflare.com/ips-v4 | while read ip; do
        echo "set_real_ip_from $ip;"
    done
    
    echo
    
    curl -s https://www.cloudflare.com/ips-v6 | while read ip; do
        echo "set_real_ip_from $ip;"
    done
    
    echo
    echo "real_ip_header CF-Connecting-IP;"
    echo "real_ip_recursive on;"
} > "$TEMP_FILE"

if [ -s "$TEMP_FILE" ]; then
    mv "$TEMP_FILE" "$CF_CONF"
    nginx -t && systemctl reload nginx
fi
EOF
    
    sudo chmod +x /etc/cron.weekly/update-cloudflare-ips
}

ensure_temporary_ssl_certificates() {
    local cert_path="/etc/ssl/certs/nginx-selfsigned.crt"
    local key_path="/etc/ssl/private/nginx-selfsigned.key"
    
    # Check if certificates already exist
    if [ -f "$cert_path" ] && [ -f "$key_path" ]; then
        debug "Temporary SSL certificates already exist"
        return 0
    fi
    
    info "Creating temporary SSL certificates for nginx..."
    
    # Create directory if it doesn't exist
    sudo mkdir -p /etc/ssl/private
    sudo mkdir -p /etc/ssl/certs
    
    # Generate temporary self-signed certificate
    sudo openssl req -x509 -nodes -days 1 -newkey rsa:2048 \
        -keyout "$key_path" \
        -out "$cert_path" \
        -subj "/C=US/ST=Temp/L=Temp/O=Temp/CN=localhost" >/dev/null 2>&1
    
    # Set proper permissions
    sudo chmod 600 "$key_path"
    sudo chmod 644 "$cert_path"
    
    debug "Temporary SSL certificates created (valid for 1 day)"
}

create_virtual_host() {
    local domain=$(load_state "DOMAIN")
    local wp_root=$(load_state "WP_ROOT")
    local php_socket=$(load_state "PHP_FPM_SOCKET")
    local waf_type=$(load_state "WAF_TYPE" "none")
    local include_www=$(load_state "INCLUDE_WWW" "true")
    
    info "Creating Nginx virtual host..."
    
    # Server names - conditionally include www
    local server_names="$domain"
    [ "$include_www" = "true" ] && server_names="$domain www.$domain"
    
    # Create site configuration
    sudo tee "/etc/nginx/sites-available/$domain" >/dev/null <<EOF
# WordPress Nginx Configuration
# Domain: $domain
# Generated by setup-wordpress.sh

# HTTP Server Block - Handles ACME challenges and redirects
server {
    listen 80;
    listen [::]:80;
    server_name $server_names;
    
    # CRITICAL: ACME challenges MUST be in HTTP block and BEFORE redirect
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        root $wp_root;
        try_files \$uri =404;
        # Disable logging for ACME requests to reduce noise
        access_log off;
    }
    
    # WAF IP restrictions for HTTP (if applicable)
$(generate_waf_restrictions_http "$waf_type")
    
    # Redirect all other HTTP traffic to HTTPS
    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

# HTTPS Server Block - Main WordPress configuration  
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
    server_name $server_names;
    
    root $wp_root;
    index index.php index.html;
    
    # SSL configuration (temporary certificates - will be updated by ssl.sh)
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    
    # Logging
    access_log /var/log/nginx/${domain}_access.log;
    error_log /var/log/nginx/${domain}_error.log;
    
    # WAF IP restrictions for HTTPS
$(generate_waf_restrictions "$waf_type")
    
    # Security headers
    include /etc/nginx/snippets/security-headers.conf;
    
    # WordPress specific rules
    include /etc/nginx/snippets/wordpress-security.conf;
    
    # Static file handling
    location ~* \.(jpg|jpeg|gif|png|webp|svg|css|js|ico|xml|woff|woff2|ttf|otf|eot)$ {
        expires 30d;
        add_header Cache-Control "public, immutable";
        access_log off;
    }
    
    # Deny access to sensitive files
    location ~* /(?:uploads|files|wp-content|wp-includes)/.*\.php$ {
        deny all;
    }

    # Deny access to dotfiles (but ACME challenges are handled in HTTP block)
    location ~ /\. {
        deny all;
    }
    
    # WordPress permalinks
    location / {
        try_files \$uri \$uri/ /index.php?\$args;
    }
    
    # PHP handling
    location ~ \.php$ {
        try_files \$uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass unix:$php_socket;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
        fastcgi_param PATH_INFO \$fastcgi_path_info;
        
        # Performance
        fastcgi_buffer_size 128k;
        fastcgi_buffers 256 16k;
        fastcgi_busy_buffers_size 256k;
        fastcgi_temp_file_write_size 256k;
        
        # Security
        fastcgi_param HTTP_PROXY "";
        fastcgi_param HTTPS on;
    }
    
    # WordPress admin area
    location ~ ^/(wp-admin|wp-login\.php) {
        # Rate limiting for login
        limit_req zone=wordpress_login burst=3 nodelay;
        
        # WAF-specific admin restrictions
$(generate_admin_restrictions "$waf_type")
        
        try_files \$uri \$uri/ /index.php?\$args;
        
        location ~ \.php$ {
            include /etc/nginx/snippets/fastcgi-php.conf;
            fastcgi_pass unix:$php_socket;
        }
    }
}
EOF

# Ensure ACME challenge directory exists
local wp_root=$(load_state "WP_ROOT")
local wp_user=$(load_state "WP_USER")

sudo mkdir -p "$wp_root/.well-known/acme-challenge/"
sudo chown -R "$wp_user:wordpress" "$wp_root/.well-known/"
sudo chmod -R 755 "$wp_root/.well-known/"
debug "ACME challenge directory prepared"

}

generate_admin_restrictions() {
    local waf_type=$1
    
    case "$waf_type" in
        "none")
            echo "        # No additional admin restrictions"
            ;;
        "cloudflare"|"cloudflare_ent")
            echo "        # Cloudflare admin access restrictions"
            echo "        # Admin access only through Cloudflare"
            ;;
        "sucuri")
            echo "        # Sucuri admin access restrictions"
            echo "        # Admin access only through Sucuri"
            ;;
        "bunkerweb")
            echo "        # BunkerWeb admin access restrictions"
            ;;
        *)
            echo "        # Custom WAF admin restrictions"
            ;;
    esac
}

generate_waf_restrictions_http() {
    local waf_type=$1
    
    case "$waf_type" in
        "none")
            echo "    # No WAF restrictions for HTTP"
            ;;
        "cloudflare"|"cloudflare_ent")
            echo "    # Allow Cloudflare IPs for HTTP (ACME challenges)"
            echo "    # Full restriction applied to HTTPS block"
            ;;
        *)
            echo "    # Lenient WAF restrictions for HTTP (ACME challenges)"
            echo "    # Full restriction applied to HTTPS block"
            ;;
    esac
}

generate_waf_restrictions() {
    local waf_type=$1
    
    case "$waf_type" in
        "none")
            echo "    # No WAF restrictions"
            ;;
        "cloudflare"|"cloudflare_ent")
            echo "    # Cloudflare IP restrictions handled by real-ip module"
            if [ "$(load_state "CF_AUTH_ORIGIN_PULLS")" = "true" ]; then
                # Ensure CA certificate exists before configuring authentication
                if [ ! -f "/etc/nginx/cloudflare-origin-pull-ca.pem" ]; then
                    warning "Cloudflare Origin CA certificate missing - downloading..."
                    ensure_cloudflare_origin_ca
                fi
                
                # Only add authentication if CA certificate exists
                if [ -f "/etc/nginx/cloudflare-origin-pull-ca.pem" ]; then
                    echo "    # Authenticated origin pulls"
                    echo "    ssl_client_certificate /etc/nginx/cloudflare-origin-pull-ca.pem;"
                    echo "    ssl_verify_client on;"
                else
                    warning "Cloudflare Origin CA certificate unavailable - skipping authentication"
                fi
            fi
            ;;
        *)
            echo "    # WAF IP restrictions"
            local waf_ips=$(load_state "WAF_IPS")
            for ip in $waf_ips; do
                echo "    allow $ip;"
            done
            echo "    deny all;"
            ;;
    esac
}

configure_security_headers() {
    info "Setting up security headers..."
    
    # Create security headers snippet
    sudo tee /etc/nginx/snippets/security-headers.conf >/dev/null <<'EOF'
# Security Headers
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "no-referrer-when-downgrade" always;
add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;

# Content Security Policy (adjust as needed)
add_header Content-Security-Policy "default-src 'self' https: data: 'unsafe-inline' 'unsafe-eval';" always;

# HSTS (enable after SSL is working)
# add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
EOF
    
    # Create WordPress security snippet
    sudo tee /etc/nginx/snippets/wordpress-security.conf >/dev/null <<'EOF'
# WordPress Security Rules

# Deny access to xmlrpc.php
location = /xmlrpc.php {
    deny all;
}

# Deny access to wp-config.php
location ~ /wp-config\.php {
    deny all;
}

# Deny access to debug.log
location ~ /wp-content/debug\.log {
    deny all;
}

# Prevent PHP execution in uploads
location ~ /wp-content/uploads/.*\.php$ {
    deny all;
}

# Block author scans
location ~ ^/author/ {
    return 403;
}

# Block WordPress backend searches
if ($query_string ~* "author=\d+") {
    return 403;
}

# Rate limiting zones are defined in main nginx.conf http context
EOF

    # Conditionally add WordFence .user.ini rule
    local plugins=$(load_state "WP_PLUGINS")
    if [[ "$plugins" =~ "wordfence" ]]; then
        info "WordFence detected, adding .user.ini Nginx rule..."
        sudo tee -a /etc/nginx/snippets/wordpress-security.conf >/dev/null <<'EOF'

# Deny access to user.ini for WordFence
location ~ /\.user\.ini$ {
    deny all;
}
EOF
    fi
    
    # Add rate limiting to main nginx.conf if not exists
    if ! grep -q "limit_req_zone.*wordpress_login" /etc/nginx/nginx.conf; then
        sudo sed -i '/http {/a \    # WordPress rate limiting\n    limit_req_zone $binary_remote_addr zone=wordpress_login:10m rate=5r/m;\n    limit_req_zone $binary_remote_addr zone=wordpress_api:10m rate=30r/m;\n' /etc/nginx/nginx.conf
    fi
}

enable_site_config() {
    local domain=$(load_state "DOMAIN")
    
    info "Enabling site configuration..."
    
    # Create symlink
    sudo ln -sf "/etc/nginx/sites-available/$domain" "/etc/nginx/sites-enabled/$domain"
    
    # Remove default site if exists
    sudo rm -f /etc/nginx/sites-enabled/default
}

test_nginx_config() {
    info "Testing Nginx configuration..."
    
    if sudo nginx -t 2>/dev/null; then
        success "Nginx configuration valid"
        restart_service "nginx"
        return 0
    fi
    
    # Capture the actual error
    local nginx_error=$(sudo nginx -t 2>&1)
    warning "Nginx configuration test failed:"
    echo "$nginx_error" | grep -E "(error|emerg)" | head -3
    
    # Check if it's an SSL certificate issue
    if echo "$nginx_error" | grep -q "certificate\|SSL\|ssl"; then
        warning "SSL certificate issue detected - attempting to fix..."
        
        # Check for Cloudflare Origin CA certificate issue
        if echo "$nginx_error" | grep -q "cloudflare-origin-pull-ca.pem"; then
            warning "Missing Cloudflare Origin CA certificate - downloading..."
            ensure_cloudflare_origin_ca
        fi
        
        # Ensure temporary SSL certificates exist
        ensure_temporary_ssl_certificates
        
        # Test again after fixing certificates
        if sudo nginx -t 2>/dev/null; then
            success "Nginx configuration fixed with certificates"
            restart_service "nginx"
            return 0
        fi
    fi
    
    # Last resort: check for inconsistent state and rebuild nginx config
    warning "Attempting to rebuild nginx configuration due to persistent errors..."
    if rebuild_nginx_config; then
        success "Nginx configuration rebuilt successfully"
        restart_service "nginx"
        return 0
    fi
    
    error "Nginx configuration test failed - manual intervention required"
    return 1
}

rebuild_nginx_config() {
    local domain=$(load_state "DOMAIN")
    
    if [ -z "$domain" ]; then
        error "Domain not found in state - cannot rebuild nginx config"
        return 1
    fi
    
    warning "Rebuilding nginx configuration for $domain..."
    
    # Check if SSL was configured
    if ! state_exists "SSL_CONFIGURED"; then
        warning "SSL not configured - disabling advanced features for rebuild"
        # Temporarily disable Cloudflare origin pulls to avoid CA certificate issues
        local orig_cf_auth=$(load_state "CF_AUTH_ORIGIN_PULLS")
        save_state "CF_AUTH_ORIGIN_PULLS" "false"
        
        # Recreate virtual host with basic configuration
        create_virtual_host
        
        # Restore original setting
        save_state "CF_AUTH_ORIGIN_PULLS" "$orig_cf_auth"
        
        debug "Basic nginx configuration rebuilt"
        return 0
    fi
    
    # If SSL was configured, rebuild with full features
    create_virtual_host
    debug "Full nginx configuration rebuilt"
    return 0
}

ensure_cloudflare_origin_ca() {
    local ca_path="/etc/nginx/cloudflare-origin-pull-ca.pem"
    local ca_url="https://developers.cloudflare.com/ssl/static/authenticated_origin_pull_ca.pem"
    
    debug "Downloading Cloudflare Origin CA certificate..."
    
    # Create nginx directory if it doesn't exist
    sudo mkdir -p /etc/nginx
    
    # Download CA certificate with timeout and retry
    if sudo curl -fsSL --max-time 10 --retry 2 "$ca_url" -o "$ca_path"; then
        sudo chmod 644 "$ca_path"
        debug "Cloudflare Origin CA certificate downloaded successfully"
        return 0
    else
        warning "Failed to download Cloudflare Origin CA certificate"
        # Clean up partial download
        sudo rm -f "$ca_path"
        return 1
    fi
}

# Redis configuration for Nginx (if enabled)
configure_nginx_redis() {
    local redis_enabled=$(load_state "ENABLE_REDIS" "false")
    
    if [ "$redis_enabled" != "true" ]; then
        return 0
    fi
    
    info "Configuring Nginx Redis cache..."
    
    # This would add Redis caching directives
    # Implementation depends on specific Redis module used
}

debug "Nginx module loaded successfully"
